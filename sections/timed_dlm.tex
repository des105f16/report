% !TEX root = ../master.tex

\newcommand{\tat}{\;@\;} % timed at (@)
\newcommand{\tdor}{\;||\;} % timed dlm or (||)

\section{Timed Decentralized Label Model}
The Timed Decentralized Label Model (TDLM) is an extension to the original DLM which uses the concepts of DLM and extends the security labels with time policies. \cite{pedersen2015}.
The TDLM time policies are attached to read or write policies, adding time-based access restrictions to labeled data.
As opposed to \thetool, it also employs differing between read and write policies, as well as principal hierarchies.
What we are interested in is the usage of TDLM and what kinds of policies can be expressed.
Therefore we will first explore its usage and afterwards point out its shortcomings.

\subsection{Key Concepts}

The time-extended policies are on the form: $\{ o: r_1, r_2, \dots, r_n \}$, where $o$ or any reader $r_i$ can have an attached clock comparison.
If a clock comparison is added to the owner of a policy, it applies to any reader in that policy.
The policy given below simply states that the principal $r_1$ is not allowed to read the attached value until the clock variable $x$ is greater than 500 ms.
  \[ \{ o : r_1(x > 500), r_2, r_3 \} \]
There are no \emph{clock variable parameters} attached to $x$, so no reset rules have been defined, meaning that once 500 ms has passed $r_1$ may read infinitely many times, or until $x$ is reset elsewhere.

Extending on the previous example, we now have that $x$ includes some simple reset rules.
  \[ \{ o : r_1(x[1000;0] > 500), r_2, r_3 \} \]
Here we have specified that once the clock reaches an \emph{upper limit}, in this case 1000, it is reset to its \emph{reset value} 0.
Now, $r_1$ has a 500 ms window every second to read the value as much as possible.

Alternatively, and not excluding the use of the previous reset method, we can add reset events to a clock variable, which will reset the its value whenever the event is triggered.
  \[ \{ o : r_1(x[?xreset;0] > 500)[*xreset], r_2, r_3 \} \]
$[?xreset]$ names a reset event name for $x$, while $[*xreset]$ triggers the event $xreset$ any time $r_1$ reads the attacked value.
Now, instead of resetting every 1 second, $x$ is reset to 0 any time that $r_1$ reads the attached value, effectively doing so that $r_1$ must wait at least 500 ms between each read.

\subsection{Comparison}

\begin{tabular}{|l|l|}
  \hline
  Timed DLM & CTIF \\ \hline
  $\{s_i : u_i, e_j (x[?reset : 1]^{\{ !s_i: \}} > 90)[*reset]; !s_i: \}$ & $\{s \rightarrow u, e \tat e: 90d \}$ \\ \hline
  ??? & $\{ chkr \rightarrow u \tat 10m * 3 \}$ \\ \hline

\end{tabular}
