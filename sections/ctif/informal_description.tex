% !TEX root = ../../master.tex

\section{Scope}
We have tried to include as many C constructs as possible, in order to properly ascertain the usefulness of \thelang.
However, certain aspects of C have been either simplified or completely left out.

In the following is a crude list with what is currently supported in \thelang.
Following the list will be some elaborations where necessary.
\begin{itemize}
  \item Variables
  \item Simple types (int, bool, char, string)
  \item Struct type definitions
  \item Pointer declarations
  \item Function prototypes, declarations, and calls
  \item Boolean and arithmetic operators
  \item \emph{if}- and \emph{while} control structures
  \item External libraries
\end{itemize}

\myparagraph{Structs}
It is possible to make struct definitions, so that the defined type can be used as any other type throughout a program.
However, it is not possible to initialize a struct.
\mikael{Måske noget om vores problemer ift. tid? Og om det ulogiske ved label på en type?}

\myparagraph{Pointers}
It is only possible to make pointer declarations.
Pointer dereferencing and address expressions are not allowed.
It is deemed to big of a subject to handle within the scope of this report, especially when trying to take into consideration pointer arithmetics.\footnote{\url{https://www.securecoding.cert.org/confluence/display/c/EXP08-C.+Ensure+pointer+arithmetic+is+used+correctly}}
In \cite{muller2015cif} the simple pointer operations are handled undifferently from any other declaration or assignment, and they prohibit the use of pointer arithmetic.\mikael{Skal stadig forklares bedre, men nu er kilderne der.}

Having pointer declarations allows us to reference arrays, even though we cannot initialize an array.

\myparagraph{Boolean and arithmetic operators}
The following boolean and arithmetic operators are allowed:
\[ \tk +, \tk - \text{(unary and binary)}, \tk *, \tk /, \tk{\&\&}, \tk{||}, \tk{!} \]

Operator precedence has no say for our compiler, as we are only interested in what operands are used in expressions.
The actual operator precedence checks are only used for, and therefore handled by, the C compiler.

\section{Informal Description}
The main extension of C found in \thelang~ is of course applying labels to values and functions.
Labels are declared between the type and the identifier of a variable, or between the return type and identifier of a function.
The syntax for labels consists of 5 components:
\begin{itemize}
  \item delimiters \dlmc{\{\{ \}\}}
  \item join operator \dlmc{;}
  \item identifiers -- e.g. \dlmc{owner}, \dlmc{reader}, or \dlmc{variable}
  \item policy operator \dlmc{->} -- e.g. \dlmc{\{\{owner->reader1, reader2\}\}}
  \item special values \dlmc{_} (underscore, for bottom label) and \dlmc{^} (caret, for top label)
\end{itemize}

Along with the 3 constructs:
\begin{itemize}
  \item if acts for \dlmc{-->? p1, p2 \{ /* statements */ \}}
  \item declassify \dlmc{<|v, l|>}
  \item output channel \dlmc{p1, p2 <- foo();}
\end{itemize}

Unlike types, labels can be omitted completely, which has two applications.
Firstly, it is possible to take old code and incrementally apply labels.
Secondly, it can be used to apply labels only where completely necessary, and relying on inference for the rest, thus limiting the clutter of labels throughout a program.

The following subsections will describe the label constructions implemented by \thelang.
The description will follow the password checker example from \cref{example:sec:check_password}.
The fully labeled source can be seen in \cref{example:code:check_password-explicit}.

\lstinputlisting[float, style=dlmc, numbers=left, caption={Labelled password checker example}, label=example:code:check_password-explicit]{dlm_examples/report/check_password-explicit.ncif}

\subsection{Function declarations}
The first thing we would want to label in a program is what can be seen as the bigger components; the functions that either obtain data from outside or send data to outside the program -- our channels.
In \thelang{} we have no distinction between input channels and any other function with a return value.
However, output channels are distinguishable by having the \dlmc{<-} construct, preceded by one or more principals.
Output channels are handled the same as other functions.
Additionally, the effective reader sets of the labels of the arguments are compared with that of the output channel.

For \dlmc{check_password} we have the 3 auxiliary functions as well as the \dlmc{check_password} function itself, which we would label as so:\\
\begin{minipage}{\linewidth}
\lstinputlisting[style=dlmc, numbers=left, linerange={11-15}, firstnumber=11]{dlm_examples/report/check_password-explicit.ncif}
\end{minipage}

Here we have two principals: user (u) and password checker (pc).\footnote{We make use of the \dlmc{principal} declaration in the full example to simulate the actual obtaining of system principals.}
The user provides some login information, to which he is the owner.
The password checker is a trusted principal which has access to the user database.
The final output is sent to an output channel which is readable only be the user.

\dlmc{check_password} returns the comparison result, which is owned by and readable by the user only.
Here we also need to add labels to the parameters, otherwise we would not be able to statically check the function, as the actual labels for the parameters could differ between different calls to the function, but by supplying the labels we know that they will have policies no more strict.
When supplied with a label, parameters are treated as any other variable when evaluating a function declaration.
However, if no label is supplied for a parameter, that parameter is recognized as a \emph{constant label}, which means that when running the inference algorithm we cannot lessen the label of a parameter in the same way we could a \emph{variable label}.

\myparagraph{Parameters}
Another interesting possibility when declaring the return label is the ability to reference parameter labels.
By default, an unlabeled function will have an implicit label which is the join of all of its parameters ($\bot$ if it has none).
This is also how external functions are always labeled.
This is done by simply stating the parameter name in the label, and possibly joining it with other policies by using the join operator.

This ability to reference parameters is useful when declaring helper methods that should maintain the policies of its parameters.
For example, we could have made a \dlmc{strcmp2} method which takes the two strings to compare, as well as some integer to limit the amount of characters we would want to compare.
Then we could have declared that function as: \\
\begin{minipage}{\linewidth}
  \centering
  \dlmc{int \{\{s1;s2\}\} strcmp2(char * s1, char * s2, int \{\{_\}\} x);}
\end{minipage}

This is a form of label polymorphism, as the return label of \dlmc{strcmp2} will always depend on the calling arguments \dlmc{s1} and \dlmc{s2}, which can differ depending on its usage.

\subsection{Variable declarations}
The labeling of variable declarations is done mainly to oblige the return values of functions and input, given by either parameters or auxiliary function calls.
This is also why most of these labels are easier to infer, and can therefore often be left out, as we shall see later in this section.

For \dlmc{check_password} we have the following labeling of variables:\\
\begin{minipage}{\linewidth}
\lstinputlisting[style=dlmc, numbers=left, linerange={16-19}, firstnumber=16]{dlm_examples/report/check_password-explicit.ncif}
\end{minipage}

The labeling applied here is done so that it obliges the different inputs to the method.
The most noteworthy thing here is the labeling of \dlmc{match}, as it through its assignment within both the \dlmc{while} and \dlmc{if} blocks will implicitly obtain knowledge of all other labeled values.
It is therefore labeled with the join of all those labels: \dlmc{\{\{u->;pc->\}\}} so that it is at most as strict as all.

\subsection{If-acts-for and declassification}\label{ctif:informal:ifactsfor_declassify}
Going into \dlmc{check_password} we have data that is privy to the user as well as data that is not.
So before we can return the result to the user, we need to explicitly declare that in this particular case it is an intentional leak of the password checker's data (the user db and the internals of \dlmc{check_password}).

This is done with the declassification delimiter \dlmc{<| |>} which takes two arguments, an expression to be declassified as well as the new label.
For \dlmc{check_password} we need to declassify and return \dlmc{match}:\\
\begin{minipage}{\linewidth}
\lstinputlisting[style=dlmc, numbers=left, linerange={28-30}, firstnumber=28]{dlm_examples/report/check_password-explicit.ncif}
\end{minipage}

As can be seen we also need to obtain the proper authority before such a declassification is possible.
This is done by using the \emph{if-acts-for} statement, identified by the \dlmc{-->?}, which is preceded by type of authority and followed by principals to acquire authority for.
During compile time checking we do not differ between the special keywords \dlmc{this} and \dlmc{caller}.

In this case we need \dlmc{u} in order to add \dlmc{u} as a reader to its own policy.
We also need to clear the return value's label of the policy of \dlmc{pc}, as explained in the beginning of this subsection.

It is possible to leave out the explicit label of the declassification, as we will see in the following subsection.

\subsection{Inference}
As we have argued repeatedly throughout this report, having to declare labels for every value or function can be time-consuming and can cause a clutter in a program.
Therefore we can rely on inference so that many labels can be omitted.
In \cite{myers1997} it is only described what leaving out labels for variables and parameters mean (see \cref{dlm:inferring_labels}), and not functions.
Therefore we have reasoned about the implications of leaving out the function label and come up with a reasonable solution, so that we can leave out those labels and still expect proper results.

As we have seen, explicit labels can be applied to the three types of declarations: function, parameter, and variable, as well as in the declassification expression.
Here we will explain what it means to leave out any of those labels in a program.
An overview of the different rules that apply are given here:
\begin{table}[H]
  \begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \textbf{Construct} & \textbf{Default label} \\ \hline \hline
    Function & The join of all parameter labels \\ \hline
    Parameter & Constant label \\ \hline
    Variable & Variable label \\ \hline
    Declassification & Variable label \\ \hline
  \end{tabularx}
  \caption{Default labels for unlabeled constructs}
  \label{informal:table:default_labels}
\end{table}

\mikaelin{Write about inference.}
