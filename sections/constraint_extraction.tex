% !TEX root = ../master.tex

\newcommand{\iR}{\mathcal{R}}
\newcommand{\iD}{\mathcal{D}}
\newcommand{\iV}{\mathcal{V}}
\newcommand{\iF}{\mathcal{F}}
\newcommand{\iS}{\mathcal{S}}
\newcommand{\iE}{\mathcal{E}}
\newcommand{\iL}{\mathcal{L}}
\newcommand{\iO}{\mathcal{O}}

\newcommand{\iLV}{\mathbf{LV}}
\newcommand{\ilv}{lv}

\newcommand{\dblSq}[1]{[\![ #1 ]\!]}

\newcommand{\rspace}{\\[1em]}
\newcommand{\dsWhere}[1]{\quad \text{ where } #1}
\newcommand{\dsAnd}[1]{\quad \text{ and } #1}
\newcommand{\dsIf}[1]{\quad \text{ if } #1}

\section{Constraint Extraction}

\subsection{Semantic Domains}
In the following, $\mathbb P$ denotes the power set.
\begin{align*}
\iLV    & = v(\iVar) \cup c(\iVar) \cup p(\mathbb{L}) \cup j(\iLV \times \iLV) \\
\iEnvL  & = \iVar \cup \{ \ia, \ib \} \rightharpoonup \iLV \\
\iEnvP  & = \iFun \cup \{ \ifb \} \rightharpoonup \iLV \times \mathbb P (\iLV \times \iVar) \\
\iCstr  & = \mathbb P (\iLV \times \iLV)
\end{align*}

$\iLV$~ is a set of \emph{Label Values}, which contains tagged values:
\begin{description}
  \item[$v$] -- Variable labels with variable identifier
  \item[$c$] -- Constant labels with variable identifier
  \item[$p$] -- Policy labels, as those described in DLM
  \item[$j$] -- Join labels, the join of two label values
\end{description}

$\iEnvL$ is the label environment, which maps variable identifiers, and the two special identifiers $\ia$ (authority) and $\ib$ (block), to label values.
The special values are propagated through scope throughout a program.

$\iEnvP$ is the function environment, which maps function identifiers, and the special identifier $\ifb$ (function block), to a tuple containing the label value of the function along with all argument label value and identifier tuples.
The function block identifier is used for return statements so that the ``surrounding'' function label can be looked up.

$\iCstr$ is a set of constraint tuples, where any $(\ilv_1, \ilv_2) \in \iCstr$ can be seen as representing a constraint: $" \; LV_1 \sqsubseteq LV_2 \; "$.

\subsection{Semantic Functions}
\begin{align*}
\iR & : \iProg \rightarrow \iCstr \\
\iD & : \iDec \rightarrow \iCstr \times \iEnvL \times \iEnvP \\
\iV & : \iDecv \rightarrow \iCstr \times \iEnvL \\
\iF & : \iDecf \rightarrow \iCstr \times \iEnvL \times \iEnvP \\
\iS & : \iStm \rightarrow \iCstr \times \iEnvL \\
\iE & : \iExp \rightarrow \iCstr \times \iLV \\
\iL & : \iLbl \cup \iPol \rightarrow \iLV \cup \{ \varepsilon \}
\end{align*}

\subsection{Semantic Equations}

\subsubsection{Program and Declaration}
\begin{align*}
& \iR\dblSq{D} = \icstr \dsWhere{\iD\dblSq{D} \; empty\icstr \; empty\ienvL \; empty\ienvP = (\icstr, \ienvL, \ienvP)} \rspace
& \iD\dblSq{D_V} \; \icstr \; \ienvL \; \ienvP = (\icstr_2, \ienvL_2, \ienvP) \dsWhere{\iV\dblSq{D_V} \; \icstr \; \ienvL \; \ienvP = (\icstr_2, \ienvL_2)} \rspace
& \iD\dblSq{D_F} \; \icstr \; \ienvL \; \ienvP = \iF\dblSq{D_F} \; \icstr \; \ienvL \; \ienvP \rspace
& \iD\dblSq{D_1 \; D_2} \; \icstr \; \ienvL \; \ienvP = (\icstr_3, \ienvL_3, \ienvP_3) \\
& \quad \text{ where } \iD\dblSq{D_2} \; \icstr_2 \; \ienvL_2 \; \ienvP_2  = (\icstr_3, \ienvL_3, \ienvP_3) \\
& \quad \text{ and } \iD\dblSq{D_1} \; \icstr \; \ienvL \; \ienvP = (\icstr_2, \ienvL_2, \ienvP_2) \\
& \textit{Alternatively: } \iD\dblSq{D_1 \; D_2} = \iD\dblSq{D_2} \circ \iD\dblSq{D_1}
\end{align*}

\subsubsection{Label}
\begin{align*}
& \iL\dblSq{\varepsilon} \; \ienvL = \varepsilon \rspace
%
& \iL\dblSq{\tk{\{\{} pol \tk{\}\}}} \; \ienvL = \iL\dblSq{pol} \; \ienvL \rspace
%
& \iL\dblSq{pol_1 \tk ; pol_2} \; \ienvL = j(\ilv_1, \ilv_2) \\
& \dsWhere{\iL\dblSq{pol_1} \; \ienvL = \ilv_1} \\
& \dsAnd{\iL\dblSq{pol_2} \; \ienvL = \ilv_2} \rspace
%
& \iL\dblSq{x} \; \ienvL = \ienvL x \rspace
%
& \iL\dblSq{p_0 \tk{->} p_1 \tk , p_2 \tk, \dots \tk , p_k} \; \ienvL = p(\{p_0' \rightarrow p_1', p_2', \dots, p_k'\}) \\
& \dsWhere{p_i' = principal(p_i) \text{, for } 0 \leq i \leq k} \rspace
%
& \iL\dblSq{\tk \_} \; \ienvL = p(\bot) \rspace
& \iL\dblSq{\tk{\^{}}} \; \ienvL = p(\top)
\end{align*}

\subsubsection{Variable Declaration}
\begin{align*}
% with expression
& \iV\dblSq{t \; L \; x \tk = E} \; \icstr \; \ienvL \; \ienvP = (\icstr \cup \icstr_2 \cup \{ c \}, \ienvL[x \mapsto \ilv_x]) \\
& \dsWhere{\iL\dblSq{L} \; \ienvL = \ilv} \\
& \dsAnd{\iE\dblSq{E} \; \ienvL \; \ienvP = (\icstr_2, \ilv_E)} \\
& \dsAnd{\ilv_x = \begin{cases}
    v(x) & \quad \text{if } \ilv = \varepsilon \\
    \ilv & \quad \text{otherwise}
  \end{cases}} \\
& \dsAnd{\ilv_\ib = \ienvL \, \ib} \\
& \dsAnd{c = " \, \ilv_E \sqcup \ilv_\ib \sqsubseteq \ilv_x \, "} \rspace
% no expression
& \iV\dblSq{t \; L \; x} \; \icstr \; \ienvL \; \ienvP = (cstr \cup \{ c \}, \ienvL[x \mapsto \ilv_x])\\
& \dsWhere{\iL\dblSq{L} \; \ienvL = \ilv} \\
& \dsAnd{\ilv_x = \begin{cases}
    v(x) & \quad \text{if } \ilv = \varepsilon \\
    \ilv & \quad \text{otherwise}
  \end{cases}} \\
& \dsAnd{\ilv_\ib = \ienvL \, \ib} \\
& \dsAnd{c = " \, \bot \sqcup \ilv_\ib \sqsubseteq \ilv_x \, "}
\end{align*}

\subsubsection{Function Declarations}
\begin{align*}
& \iF\dblSq{t_f \, L_f \, f \tk ( t_1 \, l_1 \, x_1 \tk , t_2 \, l_2 \, x_2 \tk , \dots \tk , t_n \, l_n \, x_n \tk ) S} \; \ienvL \; \ienvP
  =  (\icstr, \ienvL, \ienvP_2) \\
& \dsWhere{\iS\dblSq{S} \; \ienvL_2 \; \ienvP_2 = (\icstr, \ienvL_3)} \\
& \dsAnd{\ienvL_2 = \ienvL[x_1 \mapsto \ilv_1', x_2 \mapsto \ilv_2', \dots, x_n \mapsto \ilv_n']} \\
& \dsAnd{\ienvP_2 = \ienvP[\ifb \mapsto (\ilv_f', \emptyset), f \mapsto (\ilv_f', \{(\ilv_1', x_1), (\ilv_2', x_2), \dots, (\ilv_n', x_n)\})]} \\
& \dsAnd{\ilv_f' = \begin{cases}
    \mathlarger\sqcupl_{i = 1}^n \ilv_i & \quad \text{if } \ilv_f = \varepsilon \\
    \ilv_f & \quad \text{otherwise}
  \end{cases}} \\
& \dsAnd{\iL\dblSq{L_f} \; \ienvL = \ilv_f} \\
& \dsAnd{\ilv_i' = \begin{cases}
    c(x_i) & \quad \text{if } \ilv_i = \varepsilon \\
    \ilv_i & \quad otherwise
  \end{cases}} \\
& \dsAnd{\iL\dblSq{L_i} \; \ienvL = \ilv_i \text{ for all } 0 \leq i \leq n}
\end{align*}

\subsubsection{Function call}
In order to evaluate function calls, where the function declaration uses constant parameters, we need to replace these constants with the corresponding argument label.
In order to do this, we declare an auxiliary function:
\[ replaceConstants : \iLV \times \iEnvL \rightarrow \iLV \]

with the following definition:

\[replaceConstants(lv, \ienvL) = \begin{cases}
  \ienvL \; x & \quad \text{if } lv = c(x) \\
  j(replaceConstants(lv_1), & \quad \text{if } lv = j(lv_1, lv_2) \\
  \quad replaceConstants(lv_2)) & \\
  lv & \quad \text{otherwise}
\end{cases} \]

\begin{align*}
& \iE\dblSq{f \tk ( E_1 \tk , E_2 \tk , \dots \tk , E_n \tk )} \; \ienvL \; \ienvP = (cstr_a \cup cstr_p, \ilv_f') \\
& \dsIf{\ienvP \; f = (\ilv_f, \{(\ilv_1, x_1), (\ilv_2, x_2), \dots, (\ilv_n, x_n)\}) \text{ and}} \\
& \dsWhere{replaceConstants(\ilv_f, \ienvL_2) = \ilv_f'} \\
& \dsAnd{\icstr_a = \bigcup\limits_{i=1}^n \icstr_i} \\
& \dsAnd{\icstr_p = \bigcup\limits_{i=1}^n
  \begin{cases}
    \emptyset &\text{if } \ilv_i \in c(\iVar)\\
    \{ c(\ilv_{E_i}, \ilv_i) \} & \text{otherwise}
  \end{cases}} \\
& \dsAnd{\iE\dblSq{E_i} \; \ienvL \; \ienvP = (cstr_i, \ilv_{E_i}) \text{ for } 0 \leq i \leq n} \\
& \dsAnd{\ienvL_2 = \ienvL[x_1 \mapsto \ilv_{E_1}, x_2 \mapsto \ilv_{E_2}, \dots, x_n \mapsto \ilv_{E_n}]}
\end{align*}
