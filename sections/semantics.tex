% !TEX root = ../master.tex
\section{Semantics}

\subsection{Semantics for determining labels}
The label environment is called $\iEnvL$ and is defined by:
\[
  \iEnvL = \iVar \cup \iFun \cup \ia \cup \ib \cup \ifb \rightharpoonup \mathbb{L}
\]

\noindent where $\ia$ is the authority label, $\ib$ the block label, and $\ifb$ the function block label.

\noindent $\mathbb{L}$ is the set of all possible labels, with the six types of labels: \\

\begin{tabular}{rl}
  \textbf{Policy labels}    & Like those described earlier \\
  \textbf{Variable labels}  & Denoted $\vlbl{x}$ \\
  \textbf{Constant labels}  & Denoted $\clbl{p}$ \\
  \textbf{Lower bound}      & Denoted $\bot$ \\
  \textbf{Upper bound}      & Denoted $\top$ \\
  \textbf{Join/meet labels} & Combinations of the above-mentioned labels
\end{tabular}

\paragraph{}\noindent
The function parameters environment is called $\iEnvP$ and is defined by:
\[
  %\iEnvP = \iFun \rightharpoonup \mathbf{P}(\iVar \times \mathbb{L})
  \iEnvP = \iFun \rightharpoonup (\iVar \times \mathbb{L})_1 \cup (\iVar \times \mathbb{L})_2 \cup \dots \cup (\iVar \times \mathbb{L})_n
\]

\paragraph{}\noindent
$\iCstr$ is a set of constraints where each $c \in \iCstr$ is on the form:
\[ L_1 \sqsubseteq L_2 \; | \; L_1, L_2 \in \mathbb{L} \]


\subsubsection{Transision systems}
$(\Gamma_P, \rightarrow_P, T_P)$, with
\begin{align*}
  \Gamma_P  & = (\iProg \times \iEnvL \times \iEnvP) \\
            & \cup (\iDecv \times \iEnvL \times \iEnvP) \\
            & \cup (\iDecf \times \iEnvL \times \iEnvP) \\
            & \cup (\iEnvL \times \iCstr \times \iEnvP) \\
  T_P       & = (\iEnvL \times \iCstr \times \iEnvP)
\end{align*}

\paragraph{}\noindent
$(\Gamma_S, \rightarrow_S, T_S)$, with
\begin{align*}
  \Gamma_S & = (\iStm \times \iEnvL) \cup (\iEnvL \times \iCstr) \\
  T_S & = (\iEnvL \times \iCstr)
\end{align*}

\noindent
Where rules are on the form:
\[ \ienvP \vdash \argpart{S, \ienvL}{S}{(\ienvL, \icstr)} \]

\paragraph{}\noindent
$(\Gamma_L, \rightarrow_L, T_L)$, with
\begin{align*}
  \Gamma_L & = \iLbl \cup \iPol \cup \mathbb{L} \cup \varepsilon \\
  T_L & = \mathbb{L} \cup \varepsilon
\end{align*}

\noindent
Where rules are one of the following two forms:
\[ \ienvL \vdash l \rightarrow_L L \]
\[ \ienvL \vdash l \rightarrow_L \varepsilon \]

\subsubsection{Label declarations}
\begin{trules}
  \ctrule{LABEL}
        {\ienvL \vdash \tk{\{\{} pol \tk{\}\}} \rightarrow_L L}
        {\ienvL \vdash pol \rightarrow_L L}
        {}
  \trule{LABEL-EMPTY}
        {\ienvL \vdash \varepsilon \rightarrow_L \varepsilon}
        {}
  \ctrule{POLICY-COMP}
        {\ienvL \vdash pol_1 \tk ; pol_2 \rightarrow_L L_1 \sqcup L_2}
        {\ienvL \vdash pol_1 \rightarrow_L L_1 \quad pol_2 \rightarrow_L L_2}
        {}
  \trule{POLICY-VAR}
        {\ienvL \vdash x \rightarrow_L L}
        {where $\ienvL \, x = L$}
  \trule{POLICY-PRINCIPALS}
        {\ienvL \vdash p_0 \tk{->} p_1 \tk , p_2 \tk , \dots \tk , p_k \rightarrow_L L}
        {where $p_i' = \mathcal{P}(p_i)$, for $0 \leq i \leq k$ \\
          and $L = \{p_0' \rightarrow p_1', p_2', \dots, p_k'\}$}
\end{trules}

\subsubsection{Program}

\ctrule {PROG-COMP}
        {\argpart{P_1 \; P_2, \ienvL, \ienvP}{P}{(\ienvL_2, \icstr_1 \cup \icstr_2, \ienvP_2)}}
        {\begin{gathered}
          \argpart{P_1, \ienvL, \ienvP}{P}{(\ienvL_1, \icstr_1, \ienvP_1)} \\
          \argpart{P_2, \ienvL_1, \ienvP_1}{P}{(\ienvL_2, \icstr_2, \ienvP_2)}
        \end{gathered}}
        {}
\begin{trules}
\ctrule {PROG-VAR-DECL}
        {\argpart {D_V} {P} {(\ienvL_1, \icstr, \ienvP)} }
        {\ienvP \vdash \argpart{D_V, \ienvL}{S}{(\ienvL_1, \icstr)}}
        {}
\end{trules}

\subsubsection{Function declarations}

\ctrule {FUNC-DECL}
        {\argpart{T_f \, l_f \, f \tk ( T_1 \, l_1 \, x_1 \tk , T_2 \, l_2 \, x_2 \tk , \dots \tk , T_n \, l_n \, x_n \tk ) S, \ienvL, \ienvP}{P}{(\ienvL'', \icstr, \ienvP')}}
        {\begin{gathered}
          \ienvL \vdash l_1 \rightarrow_L L_1 \quad l_2 \rightarrow_L L_2 \quad \dots \quad l_n \rightarrow_L L_n \\
          \ienvL' \vdash l_f \rightarrow_L L_f \quad \ienvP' \vdash \argpart{S, \ienvL'''}{S}{(\ienvL'''', \icstr)}
        \end{gathered}}
        {where $L_{x_i} = \begin{cases}
          \clbl{x_i} & \quad \text{if } L_i = \varepsilon \\
          L_i & \quad otherwise
        \end{cases}\quad \text{for } 1 \leq i \leq n$ \\
          and $\ienvL' = \ienvL[x_1 \mapsto L_{x_1}, x_2 \mapsto L_{x_2}, \dots, x_n \mapsto L_{x_n}]$ \\
          and $L_f' = \begin{cases}
            \mathlarger\sqcupl_{i = 1}^n L_{x_i} & \quad \text{if } L_f = \varepsilon \\
            L_f & \quad \text{otherwise}
        \end{cases}$ \\
          and $\ienvL'' = \ienvL[f \mapsto L_f']$ \\
          and $\ienvL''' = \ienvL'[f \mapsto L_f', \ifb \mapsto L_f']$\\
          and $\ienvP' = \ienvP[f \mapsto ((L_{x_1}, x_1), (L_{x_2}, x_2), \dots, (L_{x_n}, x_n))]$}

\subsubsection{Statements}

\begin{trules}
  \ctrule{VAR-DECL-EXPR}
        {\ienvP \vdash \argpart {T \, l \, x \tk = e, \ienvL} {S} {(\ienvL[x \mapsto L_x], \icstr \cup \{ c \})} }
        {\ienvL \vdash l \rightarrow L \quad
          \ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {where $L_x = \begin{cases}
            \vlbl x & \quad \text{if } L = \varepsilon \\
            L & \quad \text{otherwise}
          \end{cases}$ \\
          and $L_\ib = \ienvL \, \ib$ \\
          and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_x \, "$ }
  \ctrule{VAR-DECL}
        {\ienvP \vdash \argpart {T \, l \, x, \ienvL} {S} {(\ienvL[x \mapsto L_x], \icstr \cup \{ c \})} }
        {\ienvL \vdash l \rightarrow L}
        {where $L_x = \begin{cases}
            \vlbl x & \quad \text{if } L = \varepsilon \\
            L & \quad \text{otherwise}
          \end{cases}$ \\
          and $L_\ib = \ienvL \, \ib$ \\
          and $c = "\bot \sqcup L_\ib \sqsubseteq L_x"$ }
\end{trules}

  \trule{EMPTY}
        {\ienvP \vdash \argpart{\varepsilon, \ienvL}{S}{(\ienvL, \emptyset)}}
        {}
  \ctrule{EXPR}
        {\ienvP \vdash \argpart{e, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {}
  \ctrule{COMP}
        {\ienvP \vdash \argpart{S_1 \; S_2, \ienvL}{S}{(\ienvL_2, \icstr_1 \cup \icstr_2)}}
        {\ienvP \vdash \argpart{S_1, \ienvL}{S}{(\ienvL_1, \icstr_1)} \quad
          \ienvP \vdash \argpart{S_2, \ienvL_1}{S}{(\ienvL_2, \icstr_2)}}
        {}
  \ctrule{WHILE}
        {\ienvP \vdash \argpart{\tk{while} \tk ( e \tk ) S, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \{ c \})}}
        {\ienvL_1, \ienvP \vdash e \rightarrow_e (\icstr_1, L_e) \quad
          \ienvP \vdash \argpart{S, \ienvL_1}{S}{(\ienvL_2, \icstr_2)}}
        {where $L_\ib = \ienvL \, \ib$ \\
          and $L_w = next$ \\
          and $\ienvL_1 = \ienvL[\ib \mapsto L_w]$ \\
          and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_w \, "$}
  \ctrule{IF}
        {\ienvP \vdash \argpart{\tk{if} \tk ( e \tk ) S, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr_1, L_e) \quad
          \ienvP \vdash \argpart{S, \ienvL_1}{S}{(\ienvL_2, \icstr_2)}}
        {where $L_\ib = \ienvL \, \ib$ \\
          and $L_{if} = next$ \\
          and $\ienvL_1 = \ienvL[\ib \mapsto L_{if}]$ \\
          and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_{if} \, "$}
  \ctrule{IF-ELSE}
        {\ienvP \vdash \argpart{\tk{if} \tk ( e \tk ) S_1 \tk{else} S_2, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \icstr_3 \cup \{ c \})}}
        {\begin{gathered}
          \ienvL, \ienvP \vdash e \rightarrow_e (\icstr_1, L_e) \\
          \ienvP \vdash \argpart{S_1, \ienvL_1}{S}{(\ienvL_2, \icstr_2)} \\
            \ienvP \vdash \argpart{S_2, \ienvL_1}{S}{(\ienvL_3, \icstr_3)}
        \end{gathered}}
          {where $L_\ib = \ienvL \, \ib$ \\
            and $L_{if} = next$ \\
            and $\ienvL_1 = \ienvL[\ib \mapsto L_{if}]$ \\
            and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_{if} \, "$}
  \ctrule{ASS}
        {\ienvP \vdash \argpart{x \tk = e, \ienvL}{S}{(\ienvL, \icstr \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {where $L_\ib = \ienvL \, \ib$ \\
          and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_x \, "$ }
  \ctrule{RET-EXPR}
        {\ienvP \vdash \argpart{\tk{return} e, \ienvL}{S}{(\ienvL, \icstr \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {where $L_\ib = \ienvL \, \ib$ \\
          and $L_\ifb = \ienvL \, \ifb$ \\
          and $c = " \, L_e \sqcup L_\ib \sqsubseteq L_\ifb \, "$}
  \trule{RET}
        {\ienvP \vdash \argpart{\tk{return}, \ienvL}{S}{(\ienvL, \emptyset)}}
        {}
  \ctrule{ACTS-THIS}
        {\ienvP \vdash \argpart{\tk{this} \tk{-{}->?} p_1 \tk , p_2 \tk , \dots \tk , p_k \; S, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvP \vdash \argpart{S, \ienvL[\ia \mapsto L_\ia']}{S}{(\ienvL_1, \icstr)}}
        {where $L_\ia = \ienvL \, \ia$ \\[0.5em]
          and $L_\ia' = L_\ia \sqcup \mathlarger\sqcupl_{i=1}^k \, \{ p_i \rightarrow \emptyset \}$}
    \ctrule{ACTS-CALLER}
        {\ienvP \vdash \argpart{\tk{caller} \tk{-{}->?} p_1 \tk , p_2 \tk , \dots \tk , p_k \; S, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvP \vdash \argpart{S, \ienvL[\ia \mapsto L_\ia']}{S}{(\ienvL_1, \icstr)}}
        {where $L_\ia = \ienvL \, \ia$ \\[0.5em]
          and $L_\ia' = L_\ia \sqcup \mathlarger\sqcupl_{i=1}^k \, \{ p_i \rightarrow \emptyset \}$}

\subsection{Semantics for deriving labels for expressions}
$(\Gamma_e, \rightarrow_e, T_e)$, with
\begin{align*}
  \Gamma_e =  & \;      \iExp \cup (\iCstr \times \mathbb{L}) \\
  T_e =       & \; (\iCstr \times \mathbb{L})
\end{align*}
Where transitions are of the form $\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L)$.

\subsubsection{Declassification}
\begin{trules}
  \ctrule{DEC}
        {\ienvL, \ienvP \vdash \tk{<|} e \tk{|>} \rightarrow_e (\icstr \cup \{ c \}, L_d)}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {where $L_\ia = \ienvL \, \ia$ \\
          and $L_{d} = next$ \\
          and $c = " \, L_e \sqsubseteq L_d \sqcup L_\ia \, "$}
  \ctrule{DEC-EXPL}
        {\ienvL, \ienvP \vdash \tk{<|} e \tk , l \tk{|>} \rightarrow_e (\icstr \cup \{ c \}, L)}
        {\ienvL \vdash l \rightarrow L \quad \ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L_e)}
        {where $L_\ia = \ienvL \, \ia$ \\
          and $c = " \, L_e \sqsubseteq L \sqcup L_\ia \, "$}
\end{trules}

\subsubsection{Arithmetics}
\begin{trules}
  \trule  {VAR-AKA-THE-ØL-RULE}
          {\ienvL, \ienvP \vdash x \rightarrow_e (\emptyset, L)}
          {where $\ienvL \, x = L$}
  \trule  {CONST}
          {\ienvL, \ienvP \vdash K \rightarrow_e (\emptyset, \bot)}
          {}
  \ctrule {BINARY-OP}
          {\ienvL, \ienvP \vdash e_1 \; op_b \; e_2 \rightarrow_e (\icstr_1 \cup \icstr_2, L_1 \sqcup L_2)}
          {\ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, L_1) \;\; \ienvL, \ienvP \vdash e_2 \rightarrow_e (\icstr_2, L_2)}
          {}
  \ctrule {UNARY-OP}
          {\ienvL, \ienvP \vdash op_u \; e \rightarrow_e (\icstr, L)}
          {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L)}
          {}
  \ctrule {PAREN}
          {\ienvL, \ienvP \vdash \tk ( e \tk ) \rightarrow_e (\icstr, L)}
          {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, L)}
          {}
\end{trules}

\subsubsection{Function call}

$(\mathbb{L}, \rightarrow_F, \mathbb{L})$,

where transitions are of the form $\ienvL \vdash L_1 \rightarrow_F L_2$.
%policy, var, const, low, up, join, meet

\begin{trules}
  \trule {POLICY}
         {\ienvL \vdash \literal{p_0 \rightarrow p_1, p_2, \dots, p_n} \rightarrow_F \literal{p_0 \rightarrow p_1, p_2, \dots, p_n}}
         {}
  \trule {CONSTANT}
         {\ienvL \vdash \clbl x \rightarrow_F \ienvL \, x}
         {}
  \trule {VARIABLE}
         {\ienvL \vdash \vlbl x \rightarrow_F x}
         {}
  \ctrule {JOIN}
         {\ienvL \vdash \literal{L_1 \sqcup L_2} \rightarrow_F \literal{L_1' \sqcup L_2'}}
         {\ienvL \vdash L_1 \rightarrow_F L_1' \quad L_2 \rightarrow_F L_2'}
         {}
  \ctrule {MEET}
         {\ienvL \vdash \literal{L_1 \sqcap L_2} \rightarrow_F \literal{L_1' \sqcap L_2'}}
         {\ienvL \vdash L_1 \rightarrow_F L_1' \quad L_2 \rightarrow_F L_2'}
         {}
  \trule {LOWER-BOUND}
         {\ienvL \vdash \bot \rightarrow_F \bot}
         {}
  \trule {UPPER-BOUND}
         {\ienvL \vdash \top \rightarrow_F \top}
         {}
\end{trules}

\ctrule {FUN-CALL-LIB}
        {\ienvL, \ienvP \vdash f \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow_e (\icstr', L')}
        {\ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, L_{e_1}) \quad e_2 \rightarrow_e (\icstr_2, L_{e_2})
          \dots e_n \rightarrow_e (\icstr_n, L_{e_n})}
        {if $\ienvL \, f = \emptyset$ \\
          and $L' = \mathlarger\sqcupl_{i=1}^n L_{e_i}$ \\
          and $\icstr' = \bigcup\limits_{i=1}^n \icstr_i$}
\ctrule {FUN-CALL}
        {\ienvL, \ienvP \vdash f \tk{<{}<{}<} p_1 \tk , p_2 \tk , \dots \tk , p_k \tk{>{}>{}>} \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow_e (\icstr_a \cup \icstr_p, L_f')}
        {\begin{gathered}
          \ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, L_{e_1}) \quad e_2 \rightarrow_e (\icstr_2, L_{e_2}) \quad \dots \quad e_n \rightarrow_e (\icstr_n, L_{e_n}) \\
          \ienvL' \vdash L_f \rightarrow_F L_f'
        \end{gathered}}
        {where $L_f = \ienvL \, f$ \\
          and $((L_1, x_1), (L_2, x_2), \dots, (L_n, x_n)) = \ienvP \, f$ \\
          and $\ienvL' = \ienvL[x_1 \mapsto L_{e_1}, x_2 \mapsto L_{e_2}, \dots, x_n \mapsto L_{e_n}]$ \\
          and $\icstr_a = \bigcup\limits_{i=1}^n \icstr_i$ \\
          and $\icstr_p = \bigcup\limits_{i=1}^n
          \begin{cases}
            \emptyset &\text{if } L_i \text{ is a constant label}\\
            \{ \literal{L_{e_i} \sqsubseteq L_i} \} & \text{otherwise}
          \end{cases}$
          }
