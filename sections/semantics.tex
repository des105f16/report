% !TEX root = ../master.tex
\section{Semantics}

\subsection{Semantics for determining labels}
The label environment is called $\iLbl$ and is defined by:
\[
  \iLbl = \iVar \cup \iFun \cup \ia \cup \ib \cup \ifb \rightharpoonup \mathbb{L}
\]

\noindent where $\ia$ is the authority label, $\ib$ the block label, and $\ifb$ the function block label.

\noindent $\mathbb{L}$ is the set of all possible labels, with the six types of labels: \\

\begin{tabular}{rl}
  \textbf{Policy labels}    & Like those described earlier \\
  \textbf{Variable labels}  & Denoted $\vlbl{x}$ \\
  \textbf{Constant labels}  & Denoted $\clbl{p}$ \\
  \textbf{Lower bound}      & Denoted $\bot$ \\
  \textbf{Upper bound}      & Denoted $\top$ \\
  \textbf{Join/meet labels} & Combinations of the above-mentioned labels
\end{tabular}

\subsubsection{Transision system}
$(\Gamma, \rightarrow, T)$, with
\begin{align*}
  \Gamma & = (\iProg \times \iLbl)
                  \cup (\iDecv \times \iLbl)
                  \cup (\iDecf \times \iLbl)
                  \cup (\iStm \times \iLbl)
                  \cup (\iLbl \times \iCstr) \\
  T & = (\iLbl \times \iCstr)
\end{align*}

\subsubsection{Program}

\ctrule {PROG-COMP}
        {\argpart{P_1 \; P_2, lbl}{}{(lbl_2, cstr_1 \cup cstr_2)}}
        {\argpart{P_1, lbl}{}{(lbl_1, cstr_1)} \quad
          \argpart{P_2, lbl_1}{}{(lbl_2, cstr_2)}}
        {}

\subsubsection{Variable declarations}

\begin{trules}
  \ctrule{VAR-DECL-EXPR}
        {\argpart {T \, l \, x \tk = e, lbl} {} {(lbl[x \mapsto l_x], cstr \cup \{ c \})} }
        {lbl \vdash e \rightarrow_e (cstr, l_e)}
        {where $l_x = \begin{cases}
            \vlbl x & \quad \text{if } l = \varepsilon \\
            l & \quad \text{otherwise}
          \end{cases}$ \\
          and $l_\ib = lbl \, \ib$ \\
          and $c = "l_e \sqcup l_\ib \sqsubseteq l_x"$ }
  \trule{VAR-DECL}
        {\argpart {T \, l \, x, lbl} {} {(lbl[x \mapsto l_x], cstr \cup \{ c \})} }
        {where $l_x = \begin{cases}
            \vlbl x & \quad \text{if } l = \varepsilon \\
            l & \quad \text{otherwise}
          \end{cases}$ \\
          and $l_\ib = lbl \, \ib$ \\
          and $c = "\bot \sqcup l_\ib \sqsubseteq l_x"$ }
\end{trules}

\subsubsection{Function declarations}

\ctrule {FUNC-DECL}
        {\argpart{T_f \, l_f \, f \tk ( T_1 \, l_1 \, x_1 \tk , T_2 \, l_2 \, x_2 \tk , \dots \tk , T_n \, l_n \, x_n \tk ) S, lbl}{}{(lbl_1, cstr)}}
        {\argpart{S, lbl_2}{}{(lbl_3, cstr)}}
        {where $l_{x_i} = \begin{cases}
          \clbl{x_i} & \quad \text{if } l_i = \varepsilon \\
          l_i & \quad otherwise
        \end{cases}\quad \text{for } 1 \leq i \leq n$ \\
          and $l_f' = \begin{cases}
            \mathlarger\sqcupl_{i = 1}^n l_{x_i} & \quad \text{if } l_f = \varepsilon \\
            l_f & \quad \text{otherwise}
        \end{cases}$ \\
          and $lbl_1 = lbl[f \mapsto l_f']$ \\
          and $lbl_2 = lbl_1[x_1 \mapsto l_{x_1}, x_2 \mapsto l_{x_2}, \dots, x_n \mapsto l_{x_n}, \ifb \mapsto l_f']$}

\subsection{Semantics for deriving labels for expressions}
$(\Gamma_e, \rightarrow_e, T_e)$, with
\begin{align*}
  \Gamma_e =  & \;      \iExp \cup (\iCstr \times \mathbb{L}) \\
  T_e =       & \; (\iCstr \times \mathbb{L})
\end{align*}
Where transitions are of the form $lbl \vdash e \rightarrow_e (cstr, l)$.

\subsubsection{Declassification}
\begin{trules}
  \ctrule{DEC-EXPL}
        {lbl \vdash \tk{<|} e \tk , l \tk{|>} \rightarrow_e l }
        {lbl \vdash e \rightarrow_e l_e}
        {where $l \in \mathbb{L}$ \\
          and $l_\ia = lbl \, \ia$ \\
          and $l_e \sqcup l_\ia \sqsubseteq l$}
\end{trules}

\subsubsection{Function call}
\begin{trules}
  \trule  {FUN-CALL-NO-ARGS}
          {lbl \vdash f \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow \bot}
          {where $n = 0$}
  \ctrule {FUN-CALL-LIB}
          {lbl \vdash f \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow_e l}
          {lbl \vdash (e_1, e_2, \dots, e_n) \rightarrow_e (l_{e_1}, l_{e_2}, \dots,  l_{e_n})}
          {where $lbl \, f = \emptyset$ \\
            and $n > 0$ \\[0.2em]
            and $l = \mathlarger\sqcupl_1^n l_{e_i} \; | \; 0 \leq i \leq n$}
\end{trules}

\subsubsection{Arithmetics}
\begin{trules}
  \trule  {VAR}
          {lbl \vdash x \rightarrow_e l}
          {if $lbl \, x = l$}
  \trule  {CONST}
          {lbl \vdash c \rightarrow \bot}
          {}
  \ctrule {BINARY-OP}
          {lbl \vdash e_1 \; op_b \; e_2 \rightarrow_e l}
          {lbl \vdash e_1 \rightarrow_e l_1 \;\; lbl \vdash e_2 \rightarrow_e l_2}
          {where $l = l_1 \sqcup l_2$}
  \ctrule {UNARY-OP}
          {lbl \vdash op_u \; e \rightarrow_e l}
          {lbl \vdash e \rightarrow_e l}
          {}
  \ctrule {PAREN}
          {lbl \vdash \tk ( e \tk ) \rightarrow_e l}
          {lbl \vdash e \rightarrow_e l}
          {}
\end{trules}

\subsection{Semantics for determining constraints}
The constraint environment is called $\iCstr$ and is defined by:
\[
  \iCstr = \iDecv \cup \iStml \cup \iExpl \rightharpoonup \mathbb{C}
\]
Where $\mathbb{C}$ is the set of constraints, with $\forall c \in \mathbb{C} . c = l_1 \sqsubseteq l_2 | l_1, l_2 \in \mathbb{L}$.

\subsubsection{Transision system}
$(\Gamma_{C}, \rightarrow_{C}, T_{C})$, with
\begin{align*}
  \Gamma_{C} =  & \;        (\iDecv \times \iLbl \times \iCstr) \\
                & \;  \cup  (\iStml \times \iLbl \times \iCstr) \\
                & \;  \cup  (\iExpl \times \iLbl \times \iCstr) \\
                & \;  \cup  (\iLbl \times \iCstr)               \\
  T_{C} =       & \;  (\iLbl \cup \iCstr)
\end{align*}

\subsubsection{Variable declaration and assignment}

\begin{trules}
  \ctrule{VAR-DECL-ASS}
        {\argpart {T \, l \, x \tk = e, lbl, cstr} {C} {(lbl, cstr')} }
        {\argpart {D_V, lbl, cstr[\mapsto c]} {C} {(lbl, cstr')} }
        {where $l = \epsilon$\\
          and $lbl \vdash e \rightarrow_L l_e$\\
          and $l_x = lbl \, x$\\
          and $l_\ib = lbl \, \ib$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_x$}
  \trule{VAR-DECL-NO-ASS}
        {\argpart {T \, l \, x, lbl, cstr} {C} {(lbl, cstr)}}
        {}
  \ctrule{ASS}
        {\argpart {x \tk = e, lbl, cstr} {C} {(lbl, cstr')}}
        {\argpart {S_L, lbl, cstr[\mapsto c]} {C} {(lbl, cstr')}}
        {where $lbl \vdash e \rightarrow_L l_e$\\
          and $l_x = lbl \, x$\\
          and $l_\ib = lbl \, \ib$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_x$}
\end{trules}

\subsubsection{Return statement}

\begin{trules}
  \ctrule{RET}
        {\argpart {\tk{return} e, lbl, cstr} {C} {(lbl, cstr')} }
        {\argpart {S_L, lbl, cstr[\mapsto c]} {C} {(lbl, cstr')} }
        {where $lbl \vdash e \rightarrow_L l_e$\\
          and $l_\ifb = lbl \, \ifb$\\
          and $l_\ib = lbl \, \ib$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_\ifb$}
  \ctrule{RET-EMPTY}
        {\argpart {\tk{return}, lbl, cstr} {C} {(lbl, cstr)} }
        {}
        {}
        {}
\end{trules}

\subsubsection{Conditional statements}

\begin{trules}
  \ctrule{WHILE}
        {\argpart {\tk{while} \tk ( e \tk ) S, lbl, cstr} {C} {(lbl', cstr')} }
        {\argpart {S_L, lbl'', cstr[\mapsto c]} {C} {(lbl^3, cstr'')} \;
         \argpart {S, lbl^3, cstr''} {C} {(lbl', cstr')} }
        {where $while_i$ is the next while block label name\\
          and $l_w = \vlbl{while_i}$\\
          and $l_\ib = lbl \, \ib$\\
          and $l_\ib' = l_\ib \sqcup l_w$\\
          and $lbl'' = lbl[\ib \mapsto l_\ib']$\\
          and $lbl'' \vdash e \rightarrow_L l_e$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_w$}
  \ctrule{IF}
        {\argpart {\tk{if} \tk ( e \tk ) S, lbl, cstr} {C} {(lbl', cstr')}}
        {\argpart {S_L, lbl[\ib \mapsto \ib'], cstr[\mapsto c]} {C} {(lbl'', cstr'')} \;
         \argpart {S, lbl'', cstr''} {C} {(lbl', cstr')} }
        {where $if_i$ is the next if block label name\\
          and $l_i = \vlbl{if_i}$\\
          and $l_\ib = lbl \, \ib$\\
          and $l_\ib' = l_\ib \sqcup l_i$\\
          and $lbl \vdash e \rightarrow_L l_e$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_i$}
  \ctrule{IF-ELSE}
        {\argpart {\tk{if} \tk ( e \tk ) S_1 \tk{else} S_2, lbl, cstr} {C} {(lbl', cstr')}}
        {\splitfrac{\splitfrac{\argpart {S_L, lbl[\ib \mapsto \ib'], cstr[\mapsto c]} {C} {(lbl'', cstr'')}}
         {\argpart {S_1, lbl'', cstr''} {C} {(lbl^3, cstr^3)} }}
         {\argpart {S_2, lbl^3, cstr^3} {C} {(lbl', cstr')} }}
        {where $if_i$ is the next if block label name\\
          and $l_i = \vlbl{if_i}$\\
          and $l_\ib = lbl \, \ib$\\
          and $l_\ib' = l_\ib \sqcup l_i$\\
          and $lbl \vdash e \rightarrow_L l_e$\\
          and $c = l_\ib \sqcup l_e \sqsubseteq l_i$}
\end{trules}

\subsubsection{If-acts-for statement}

\begin{trules}
  \ctrule{IF-ACTS-FOR-THIS}
        {\argpart {\tk{this} \tk{-{}->?} p_l \; S, lbl, cstr} {C} {(lbl', cstr')} }
        {\argpart {S_L, lbl[\ia \mapsto \ia'], cstr} {C} {(lbl'', cstr)} \;
         \argpart {S, lbl'', cstr} {C} {(lbl', cstr')} }
        {where $p_l \rightarrow (p_1, p_2, \dots, p_n)$\\
          and $\ia' = \ia \sqcup (\mathlarger\sqcupl\limits_1^n \{ p_i \rightarrow \emptyset \}$) }
\end{trules}

\subsubsection{Declassification}

\begin{trules}
  \ctrule{DEC-IMPL}
        {\argpart {\tk{<|} e \tk , l \tk{|>}, lbl, cstr} {C} {(lbl, cstr')} }
        {\argpart {e_L, lbl, cstr[\mapsto c]} {C} {(lbl, cstr')} }
        {where $l = \epsilon$\\
          and $dec_i$ is the next declassify label name\\
          and $l_d = \vlbl{dec_i}$\\
          and $a = lbl \; \ia$\\
          and $l_e = lbl \vdash e \rightarrow_L l_e$\\
          and $c = l_e \sqsubseteq l_d \sqcup a$}
\end{trules}
