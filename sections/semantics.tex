% !TEX root = ../master.tex
\section{Semantics}

\subsection{Semantics for determining labels}
The label environment is called $\iEnvL$ and is defined by:
\[
  \iEnvL = \iVar \cup \iFun \cup \ia \cup \ib \cup \ifb \rightharpoonup \mathbb{L}
\]

\noindent where $\ia$ is the authority label, $\ib$ the block label, and $\ifb$ the function block label.

\noindent $\mathbb{L}$ is the set of all possible labels, with the six types of labels: \\

\begin{tabular}{rl}
  \textbf{Policy labels}    & Like those described earlier \\
  \textbf{Variable labels}  & Denoted $\vlbl{x}$ \\
  \textbf{Constant labels}  & Denoted $\clbl{p}$ \\
  \textbf{Lower bound}      & Denoted $\bot$ \\
  \textbf{Upper bound}      & Denoted $\top$ \\
  \textbf{Join/meet labels} & Combinations of the above-mentioned labels
\end{tabular}

\paragraph{}\noindent
The function parameters environment is called $\iEnvP$ and is defined by:
\[
  %\iEnvP = \iFun \rightharpoonup \mathbf{P}(\iVar \times \mathbb{L})
  \iEnvP = \iFun \rightharpoonup (\iVar \times \mathbb{L})_1 \cup (\iVar \times \mathbb{L})_2 \cup \dots \cup (\iVar \times \mathbb{L})_n
\]

\paragraph{}\noindent
$\iCstr$ is a set of constraints where each $c \in \iCstr$ is on the form:
\[ l_1 \sqsubseteq l_2 \; | \; l_1, l_2 \in \mathbb{L} \]


\subsubsection{Transision systems}
$(\Gamma_P, \rightarrow_P, T_P)$, with
\begin{align*}
  \Gamma_P  & = (\iProg \times \iEnvL \times \iEnvP) \\
            & \cup (\iDecv \times \iEnvL \times \iEnvP) \\
            & \cup (\iDecf \times \iEnvL \times \iEnvP) \\
            & \cup (\iEnvL \times \iCstr \times \iEnvP) \\
  T_P       & = (\iEnvL \times \iCstr \times \iEnvP)
\end{align*}

\paragraph{}\noindent
$(\Gamma_S, \rightarrow_S, T_S)$, with
\begin{align*}
  \Gamma_S & = (\iStm \times \iEnvL) \cup (\iEnvL \times \iCstr) \\
  T_S & = (\iEnvL \times \iCstr)
\end{align*}

\noindent
Where rules are on the form:
\[ \ienvP \vdash \argpart{S, \ienvL}{S}{(\ienvL, \icstr)} \]



\subsubsection{Program}

\ctrule {PROG-COMP}
        {\argpart{P_1 \; P_2, \ienvL, \ienvP}{P}{(\ienvL_2, \icstr_1 \cup \icstr_2, \ienvP_2)}}
        {\argpart{P_1, \ienvL, \ienvP}{P}{(\ienvL_1, \icstr_1, \ienvP_1)} \quad
          \argpart{P_2, \ienvL_1, \ienvP_1}{P}{(\ienvL_2, \icstr_2, \ienvP_2)}}
        {}
\begin{trules}
\ctrule {PROG-VAR-DECL}
        {\argpart {D_V} {P} {(\ienvL_1, \icstr, \ienvP)} }
        {\ienvP \vdash \argpart{D_V, \ienvL}{S}{(\ienvL_1, \icstr)}}
        {}
\end{trules}

\subsubsection{Function declarations}

\ctrule {FUNC-DECL}
        {\argpart{T_f \, l_f \, f \tk ( T_1 \, l_1 \, x_1 \tk , T_2 \, l_2 \, x_2 \tk , \dots \tk , T_n \, l_n \, x_n \tk ) S, \ienvL, \ienvP}{P}{(\ienvL_1, \icstr, \ienvP_1)}}
        {\argpart{\ienvP_1 \vdash S, \ienvL_2}{S}{(\ienvL_3, \icstr)}}
        {where $l_{x_i} = \begin{cases}
          \clbl{x_i} & \quad \text{if } l_i = \varepsilon \\
          l_i & \quad otherwise
        \end{cases}\quad \text{for } 1 \leq i \leq n$ \\
          and $l_f' = \begin{cases}
            \mathlarger\sqcupl_{i = 1}^n l_{x_i} & \quad \text{if } l_f = \varepsilon \\
            l_f & \quad \text{otherwise}
        \end{cases}$ \\
          and $\ienvL_1 = \ienvL[f \mapsto l_f']$ \\
          and $\ienvL_2 = \ienvL_1[x_1 \mapsto l_{x_1}, x_2 \mapsto l_{x_2}, \dots, x_n \mapsto l_{x_n}, \ifb \mapsto l_f']$ \\
          and $\ienvP_1 = \ienvP[f \mapsto ((l_{x_1}, x_1), (l_{x_2}, x_2), \dots, (l_{x_n}, x_n))]$}

\subsubsection{Statements}

\begin{trules}
  \ctrule{VAR-DECL-EXPR}
        {\ienvP \vdash \argpart {T \, l \, x \tk = e, \ienvL} {S} {(\ienvL[x \mapsto l_x], \icstr \cup \{ c \})} }
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {where $l_x = \begin{cases}
            \vlbl x & \quad \text{if } l = \varepsilon \\
            l & \quad \text{otherwise}
          \end{cases}$ \\
          and $l_\ib = \ienvL \, \ib$ \\
          and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_x \, "$ }
  \trule{VAR-DECL}
        {\ienvP \vdash \argpart {T \, l \, x, \ienvL} {S} {(\ienvL[x \mapsto l_x], \icstr \cup \{ c \})} }
        {where $l_x = \begin{cases}
            \vlbl x & \quad \text{if } l = \varepsilon \\
            l & \quad \text{otherwise}
          \end{cases}$ \\
          and $l_\ib = \ienvL \, \ib$ \\
          and $c = "\bot \sqcup l_\ib \sqsubseteq l_x"$ }
\end{trules}

  \trule{EMPTY}
        {\ienvP \vdash \argpart{\varepsilon, \ienvL}{S}{(\ienvL, \emptyset)}}
        {}
  \ctrule{EXPR}
        {\ienvP \vdash \argpart{e, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {}
  \ctrule{COMP}
        {\ienvP \vdash \argpart{S_1 \; S_2, \ienvL}{S}{(\ienvL_2, \icstr_1 \cup \icstr_2)}}
        {\ienvP \vdash \argpart{S_1, \ienvL}{S}{(\ienvL_1, \icstr_1)} \quad
          \ienvP \vdash \argpart{S_2, \ienvL_1}{S}{(\ienvL_2, \icstr_2)}}
        {}
  \ctrule{WHILE}
        {\ienvP \vdash \argpart{\tk{while} \tk ( e \tk ) S, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \{ c \})}}
        {\ienvL_1, \ienvP \vdash e \rightarrow_e (\icstr_1, l_e) \quad
          \ienvP \vdash \argpart{S, \ienvL_1}{S}{(\ienvL_2, \icstr_2)}}
        {where $l_\ib = \ienvL \, \ib$ \\
          and $l_w = next$ \\
          and $\ienvL_1 = \ienvL[\ib \mapsto l_w]$ \\
          and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_w \, "$}
  \ctrule{IF}
        {\ienvP \vdash \argpart{\tk{if} \tk ( e \tk ) S, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr_1, l_e) \quad
          \ienvP \vdash \argpart{S, \ienvL[\ib \mapsto l_{if}]}{S}{(\ienvL_1, \icstr_2)}}
        {where $l_\ib = \ienvL \, \ib$ \\
          and $l_{if} = next$ \\
          and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_{if} \, "$}
  \ctrule{IF-ELSE}
        {\ienvP \vdash \argpart{\tk{if} \tk ( e \tk ) S_1 \tk{else} S_2, \ienvL}{S}{(\ienvL, \icstr_1 \cup \icstr_2 \cup \icstr_3 \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr_1, l_e) \quad
          \ienvP \vdash \argpart{S_1, \ienvL_1}{S}{(\ienvL_2, \icstr_2)} \quad
          \ienvP \vdash \argpart{S_2, \ienvL_1}{S}{(\ienvL_3, \icstr_3)}}
          {where $l_\ib = \ienvL \, \ib$ \\
            and $l_{if} = next$ \\
            and $\ienvL_1 = \ienvL[\ib \mapsto l_{if}]$ \\
            and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_{if} \, "$}
  \ctrule{ASS}
        {\ienvP \vdash \argpart{x \tk = e, \ienvL}{S}{(\ienvL, \icstr \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {where $l_\ib = \ienvL \, \ib$ \\
          and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_x \, "$ }
  \ctrule{RET-EXPR}
        {\ienvP \vdash \argpart{\tk{return} e, \ienvL}{S}{(\ienvL, \icstr \cup \{ c \})}}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {where $l_\ib = \ienvL \, \ib$ \\
          and $l_\ifb = \ienvL \, \ifb$ \\
          and $c = " \, l_e \sqcup l_\ib \sqsubseteq l_\ifb \, "$}
  \trule{RET}
        {\ienvP \vdash \argpart{\tk{return}, \ienvL}{S}{(\ienvL, \emptyset)}}
        {}
  \ctrule{ACTS-THIS}
        {\ienvP \vdash \argpart{\tk{this} \tk{-->?} p_1 \tk , p_2 \tk , \dots \tk , p_k \; S, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvP \vdash \argpart{S, \ienvL[\ia \mapsto l_\ia']}{S}{(\ienvL_1, \icstr)}}
        {where $l_\ia = \ienvL \, \ia$ \\
          and $l_\ia' = l_\ia \sqcup \mathlarger\sqcupl_{i=1}^k \, \{ p_i \rightarrow \emptyset \}$}
    \ctrule{ACTS-CALLER}
        {\ienvP \vdash \argpart{\tk{caller} \tk{-->?} p_1 \tk , p_2 \tk , \dots \tk , p_k \; S, \ienvL}{S}{(\ienvL, \icstr)}}
        {\ienvP \vdash \argpart{S, \ienvL[\ia \mapsto l_\ia']}{S}{(\ienvL_1, \icstr)}}
        {where $l_\ia = \ienvL \, \ia$ \\
          and $l_\ia' = l_\ia \sqcup \mathlarger\sqcupl_{i=1}^k \, \{ p_i \rightarrow \emptyset \}$}

\subsection{Semantics for deriving labels for expressions}
$(\Gamma_e, \rightarrow_e, T_e)$, with
\begin{align*}
  \Gamma_e =  & \;      \iExp \cup (\iCstr \times \mathbb{L}) \\
  T_e =       & \; (\iCstr \times \mathbb{L})
\end{align*}
Where transitions are of the form $\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l)$.

\subsubsection{Declassification}
\begin{trules}
  \ctrule{DEC}
        {\ienvL, \ienvP \vdash \tk{<|} e \tk{|>} \rightarrow_e (\icstr \cup \{ c \}, l_d)}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {where $l_\ia = \ienvL \, \ia$ \\
          and $l_{d} = next$ \\
          and $c = " \, l_e \sqsubseteq l_d \sqcup l_\ia \, "$}
  \ctrule{DEC-EXPL}
        {\ienvL, \ienvP \vdash \tk{<|} e \tk , l \tk{|>} \rightarrow_e (\icstr \cup \{ c \}, l)}
        {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l_e)}
        {where $l_\ia = \ienvL \, \ia$ \\
          and $l_d = next$ \\
          and $c = " \, l_e \sqsubseteq l \sqcup l_\ia \, "$}
\end{trules}

\subsubsection{Arithmetics}
\begin{trules}
  \trule  {VAR}
          {\ienvL, \ienvP \vdash x \rightarrow_e (\emptyset, l)}
          {where $\ienvL \, x = l$}
  \trule  {CONST}
          {\ienvL, \ienvP \vdash c \rightarrow_e (\emptyset, \bot)}
          {}
  \ctrule {BINARY-OP}
          {\ienvL, \ienvP \vdash e_1 \; op_b \; e_2 \rightarrow_e (\icstr_1 \cup \icstr_2, l_1 \sqcup l_2)}
          {\ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, l_1) \;\; \ienvL, \ienvP \vdash e_2 \rightarrow_e (\icstr_2, l_2)}
          {}
  \ctrule {UNARY-OP}
          {\ienvL, \ienvP \vdash op_u \; e \rightarrow_e (\icstr, l)}
          {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l)}
          {}
  \ctrule {PAREN}
          {\ienvL, \ienvP \vdash \tk ( e \tk ) \rightarrow_e (\icstr, l)}
          {\ienvL, \ienvP \vdash e \rightarrow_e (\icstr, l)}
          {}
\end{trules}

\subsubsection{Function call}

$(\mathbb{L}, \rightarrow_F, \mathbb{L})$,

where transitions are of the form $\ienvL \vdash l_1 \rightarrow_F l_2$.
%policy, var, const, low, up, join, meet

\begin{trules}
  \trule {POLICY}
         {\ienvL \vdash \literal{p_0 \rightarrow p_1, p_2, \dots, p_n} \rightarrow_F \literal{p_0 \rightarrow p_1, p_2, \dots, p_n}}
         {}
  \trule {CONSTANT}
         {\ienvL \vdash \clbl x \rightarrow_F \ienvL \, x}
         {}
  \trule {VARIABLE}
         {\ienvL \vdash \vlbl x \rightarrow_F x}
         {}
  \ctrule {JOIN}
         {\ienvL \vdash \literal{l_1 \sqcup l_2} \rightarrow_F \literal{l_1' \sqcup l_2'}}
         {\ienvL \vdash l_1 \rightarrow_F l_1' \quad l_2 \rightarrow_F l_2'}
         {}
  \ctrule {MEET}
         {\ienvL \vdash \literal{l_1 \sqcap l_2} \rightarrow_F \literal{l_1' \sqcap l_2'}}
         {\ienvL \vdash l_1 \rightarrow_F l_1' \quad l_2 \rightarrow_F l_2'}
         {}
  \trule {LOWER-BOUND}
         {\ienvL \vdash \bot \rightarrow_F \bot}
         {}
  \trule {UPPER-BOUND}
         {\ienvL \vdash \top \rightarrow_F \top}
         {}
\end{trules}

\begin{trules}
  \ctrule {FUN-CALL-LIB}
          {\ienvL, \ienvP \vdash f \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow_e (\icstr', l')}
          {\ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, l_{e_1}) \quad e_2 \rightarrow_e (\icstr_2, l_{e_2}) \quad
            \dots \quad e_n \rightarrow_e (\icstr_n, l_{e_n})}
          {if $\ienvL \, f = \emptyset$ \\
            and $l' = \mathlarger\sqcupl_{i=1}^n l_{e_i}$ \\
            and $\icstr' = \bigcup\limits_{i=1}^n \icstr_i$}
  \ctrule {FUN-CALL}
          {\ienvL, \ienvP \vdash f \tk{<{}<{}<} p_1 \tk , p_2 \tk , \dots \tk , p_k \tk{>{}>{}>} \tk ( e_1 \tk , e_2 \tk , \dots \tk , e_n \tk ) \rightarrow_e (\icstr_a \cup \icstr_p, l_f')}
          {\splitfrac
            {\ienvL, \ienvP \vdash e_1 \rightarrow_e (\icstr_1, l_{e_1}) \quad e_2 \rightarrow_e (\icstr_2, l_{e_2}) \quad \dots \quad e_n \rightarrow_e (\icstr_n, l_{e_n})}
            {\ienvL' \vdash l_f \rightarrow_F l_f'}}
          {where $l_f = \ienvL \, f$ \\
            and $((l_1, x_1), (l_2, x_2), \dots, (l_n, x_n)) = \ienvP \, f$ \\
            and $\ienvL' = \ienvL[x_1 \mapsto l_{e_1}, x_2 \mapsto l_{e_2}, \dots, x_n \mapsto l_{e_n}]$ \\
            and $\icstr_a = \bigcup\limits_{i=1}^n \icstr_i$ \\
            and $\icstr_p = \bigcup\limits_{i=1}^n
            \begin{cases}
              \emptyset &\text{if } l_i \text{ is a constant label}\\
              \{ \literal{l_{e_i} \sqsubseteq l_i} \} & \text{otherwise}
            \end{cases}$
            }
\end{trules}
