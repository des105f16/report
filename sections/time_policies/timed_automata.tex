% !TEX root = ../../master.tex

\section{Timed Automata}\label{automata}
Here we will shortly define and describe timed automata, based on \cite{alur1994theory}.

The timed automata is an extension to the $\omega$-automata formalism, allowing for the manipulation of clock-variables, as well as clock-based restrictions.
The formal definition for a timed automaton can be seen in \cref{time:def:timedautomaton}.

\begin{definition}{Timed automaton}\label{time:def:timedautomaton}
A timed automaton is a tuple $(\Sigma, S, S_0, C, E)$, where
\begin{itemize}
  \item $\Sigma$ is a finite alphabet,
  \item $S$ is a finite set of states,
  \item $S_0 \subseteq S$ is a set of start states,
  \item $C$ is a finite set of clocks, and
  \item $E \subseteq S \times S \times \Sigma \times 2^C \times \phi(C)$ gives the set of transitions. \\
    An edge $(s, s', \sigma, \lambda, \delta)$ represents a transition from state $s$ to state $s'$ on input symbol $\sigma$.
    The set $\lambda \subseteq C$ gives the clocks to be reset with this transition, and $\delta$ is a clock constraint over C.
\end{itemize}
\end{definition}

In \cref{time:ex:visualrepresentation} can be seen a visualization of a timed automaton.
Generally, for each edge we have the input $\sigma$, clock resets $\lambda$, and clock constraints $\phi(C)$.
In our examples, the input will symbolize an action performed along with the transition, reading a value with the corresponding name.
Clock resets are denoted $x := 0$, which corresponds to $\lambda = \{ x \}$, and will reset the clock variable $x$ to 0.
Finally, clock constraints are declared, denoted $(x >= 10m)?$, which is a single clock constraint for the clock variable $x$.
Several input characters, clock resets, and clock constraints can be defined for a single edge, the syntax should make it clear which are which.
It should also be noted that the time constants used will use the same time factors as those described for our time policies (see \cref{time:expressiveness}).

\begin{example}{Visual representation}\label{time:ex:visualrepresentation}
In this example we have a timed automata with the following characteristica:
\begin{itemize}
  \item $\Sigma = \{ v \} \cup \{ \varepsilon \}$
  \item $S = \{ s_0, s_1 \}$
  \item $S_0 = \{ s_0 \}$
  \item $C = \{ x \}$
  \item $E = \{ (s_0, s_1, v, \{ x \}, \emptyset), (s_1, s_0, \varepsilon, \emptyset, \{ 10m \geq x \})\}$
\end{itemize}
This timed automaton is concerned with protecting the value of $v$, which should be read with at least 10 minutes inbetween reads.
We start in state $s_0$, with all clock variables initially set to $0$ (although this is not important for this example).
At some point, we make the transition from $s_0$ to $s_1$, which is an unrestricted transition, $x$ will be reset and we perform the action of reading $v$.
Now, in $s_1$, we cannot transition back to our initial state before we have waited for at least 10 minutes, hence the restriction on the edge going from $s_1$ to $s_0$.
Once enough time has passed, we can carry out the transition and once again we are permitted to perform the first transition in order to read $v$.

  \begin{figure}[H]
    \centering
    \input{figures/ta_10m.tikz}
  \end{figure}
\end{example}

\subsection{Time policies and timed automata}\label{automata:timepolicies}
In this section, we will show how it is possible to transform \thelang{} time policies into timed automata.
This will be done by defining abstract time policies, which represent special cases, and showing for each of these a corresponding timed automaton.

We assume having a special clock variable $\tau_s$ representing the current system time, which will be used for comparing period constraints.
For readability, whenever we have a period $(p_s, p_e)$ we will use the constraint $\delta_p$, representing our period constraint:
\[ \delta_p = (p_s \leq \tau_s < p_e) \]
and its negation
\[ \lnot\delta_p = (p_s > \tau_s \geq p_e) \]

\subsubsection{Period}
A period-only policy can be seen as a tuple $(p_s, p_e, c)$, where we previously defined it as having an implicit count value of $c = \infty$.
This, however, simply means that we can read without further restrictions, as long as our period restriction holds.

\begin{figure}[H]
  \centering
  \input{figures/timed_automata/general_period.tikz}
\end{figure}

\subsubsection{Interval}
An interval-only policy is represented by a tuple $(i, c)$, with the defined implicit count value of $c = 1$.
Unlike the period-only policy, we now need a clock variable in order to limit the number of consecutive reads.
Additionally, the automaton can now be stuck in state $s_1$, while the count clock variable $c_1$ is incrementing.

\begin{figure}[H]
  \centering
  \input{figures/timed_automata/general_interval.tikz}
\end{figure}

\subsubsection{Period and count}
When adding a specific count value, we must now add clock variables in order to limit the amount of consecutive reads.
In addition, since we do not have an interval, we need the negated period constraint in order to properly reset the count whenever the system time is no longer within the period.

\begin{figure}[H]
  \centering
  \input{figures/timed_automata/general_period_2count.tikz}
\end{figure}

\subsubsection{Interval and count}


\subsubsection{Period, interval, and count}



\begin{figure}[H]
  \centering
  \input{figures/timed_automata/general_period_interval_2count.tikz}
\end{figure}
