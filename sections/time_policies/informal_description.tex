% !TEX root = ../../master.tex

\section{Extending the security model}
% extend concept of output channels with ensuring that time policies are followed
% current authority dictates whether a function call to a time-labeled value can be made or not
% simple, yet expressive, time labels attached to readers
% in order to check compile time:
% - special constructs @ and @?
% - limited to return labels and function root scope variables (if time-labeled and not handled in the function)
Extending on the concept of controlling how information should exit the system, as we did previously using channels, we want to add time constraints to the security model.
As we have different principals in our system, which have different requirements/rights, we want to be able to express multiple time policies which apply to different principals.
To do this we extend the previously defined syntax for labels and include some language constructs that simplify how to work with time considerations.
This language feature is not considered an extension of the labels defined by DLM.
One of the reasons for this is that statically determining which time policy is the most restrictive and how to join two policies together present some difficulties.
In \mikkel{Insert ref} we will go into details about these challenges.

Even though the time policies do not fit in the same model as the labels defined by DLM, we have chosen to provide a shared syntax for both types of security policies.
Grouping all the security policies together like this, will make it easier for the programmer to identify which policies apply in a specific context.

We use the \dlmc{@} symbol for all time-related language constructs.
It is used to ``attach'' time policies to principals in label declarations.
Time policies can only apply to readers.
If the owner of a policy has an attached time policy, it is meant to apply to all its readers.
The \dlmc{@} symbol will also be used for the two time constructs \dlmc{@?} (\emph{if-can-call})  and \dlmc{@} (\emph{await}), explained later in this section.

\subsection{Expressiveness}\label{time:expressiveness}
We expand on the concept of labels using a set of properties that describe rules for when, and how often, data can be read.
We want our time policies to be expressive, so that we can cover a wide variety of cases.
We therefore introduce three types of time constituents, where any combination of these will form a time policy.

In the following, we will consider time values as positive integers representing milliseconds.
For simplicity, we will use the time postfixes: $\mathbb{T} = \{ h, m, s, ms \}$, which are to be seen as factors to be applied to times.
For a value $n \in \mathbb{N}$ followed by a postfix $T \in \mathbb{T}$, we have that:
\[nT = \begin{cases}
  n \times 60 \times 60 \times 1000 & \quad\text{if } T = h \\
  n \times 60 \times 1000 & \quad\text{if } T = m \\
  n \times 1000 & \quad\text{if } T = s \\
  n & \quad\text{otherwise}
\end{cases}\]
\myparagraph{Period}
Period represents a start- and end-time, where access is only permitted within that period.
E.g. \dlmc{\{\{u->u, ec@09:00-10:00\}\}} signifies that \dlmc{ec} is only allowed to access when the time is between 09:00 and 10:00 in the morning.
In this is example there are no restrictions on the access \dlmc{u} has.

Formally we represent a period as the pair $(p_s, p_e)$ describing when a period starts (inclusive) and ends (exclusive).
A period cannot specify rules for particular dates or days of the week.

\myparagraph{Interval}
Interval is a constant value indicating the minimum amount of time there should pass between each access.
The interval can be described as a combination of milliseconds, seconds, minutes, hours and days.
E.g. \dlmc{\{\{u->u, ec@10m30s\}\}} requires a minimum of 10 minutes and 30 seconds between each access.

\myparagraph{Count}
Count is in itself without meaning, as it says how many consecutive accesses within the given period and/or interval are allowed.
However, due to default values some meaning may apply to a case such as \dlmc{\{\{u->u, ec@10m*5\}\}}, where in this case 5 consecutive accesses are allowed in a 10 minute interval.

\myparagraph{Combined time policies}
It is possible to combine two or all three of the time constituents.
The count component even requires such a combination.
Count should be considered a ``\textit{number of reads in some period or interval}''.
If an interval is declared, count specifies the number of reads in that interval (defaulting to 1).
If an interval is not declared but a period is, count specifies the number of reads in that period (defaulting to $\infty$).

\begin{example}{Time policies}
  The \dlmc{\{\{pc->u@10m*3\}\}} policy, indicates that the principal \dlmc{u} is only allowed access thrice per 10 minutes.
  Another way of explaining it; after the initial read another two reads \emph{can} follow, either way it is reset 10 minutes after the initial read.

  Another example \dlmc{\{\{u->u, ec@00:00-09:00 30m\}\}}, allows \dlmc{u} unlimited access.
  \dlmc{ec}, however, is restricted to reading between midnight and 9 in the morning, and with a minimum of 30 minutes passing between each access.
\end{example}

\subsection{Time constructs}
We have the two time constructs:

\begin{itemize}
  \item if-can-call \dlmc{@?}
  \item await \dlmc{@}
\end{itemize}

The two constructs represent run-time checks.
\dlmc{@?} takes one argument: a function identifier, and returns a boolean whether the function is callable or not, as per the time constraints.
\dlmc{@} is placed before a function call, forcing the program to busy-wait until the function is callable.

The constructs themselves currently have no run-time-related implementation.
However, they are used during compile time checking to ensure that whenever we access data with a time policy, that we have used one of these to somehow handle the time policy.

\subsection{Applications}
