% !TEX root = ../../master.tex

\newcommand{\tat}{\;@\;} % timed at (@)
\newcommand{\tdor}{\;||\;} % timed dlm or (||)
\newcommand{\tdand}{\;\&\&\;} % timed dlm and (&&)

\section{The Timed Decentralized Label Model}
The Timed Decentralized Label Model (TDLM) \cite{pedersen2015} is an extension to the original DLM.
TDLM extends on the security labels of DLM with the addition of time policies.
We are interested in is what kind of policies can be expressed.
We will first briefly explore its usage and afterwards we will compare it to \thelang.

\subsection{Usage}
The overall idea is that \emph{clock comparison} rules can be added to the policies of labels.
These rules are logical comparisons of some \emph{clock variables}, or constant values, which must hold before data can be read by the concerned principal.

\subsubsection{Clock comparisons}
Clock comparisons can be added to any principal in a policy and time policies may differ between principals.
If a clock comparison is added to the \emph{owner} of a policy, it applies to all \emph{readers} in that policy.
In the following label, a simple time restriction, containing a clock comparison, is added to the read rights of principal $r_1$:
  \[ \{ o : r_1(x > 500), r_2, r_3 \} \]
The policy simply states that the principal $r_1$ is not allowed to read the attached value until the clock variable $x$ is greater than 500 ms.
There are no \emph{clock variable parameters} attached to $x$ (see below), so no reset rules have been defined, meaning that once 500 ms has passed $r_1$ may read infinitely many times, or until $x$ is reset elsewhere.
The other readers $r_2$ and $r_3$ have no time restrictions.

\subsubsection{Upper limit and reset value}
Extending on the previous example, we now have that $x$ includes some simple reset rules:
  \[ \{ o : r_1(x[1000;0] > 500), r_2, r_3 \} \]
Here we have specified that once the clock reaches an \emph{upper limit}, in this case 1000, it is reset to its \emph{reset value} of 0.
Now, $r_1$ has a 500 ms window for every second in which it can read the attached value.

\subsubsection{Reset events}
Alternatively, and not excluding the use of the previous reset method, we can add reset events to a clock variable:
  \[ \{ o : r_1(x[?xreset] > 500)[*xreset], r_2, r_3 \} \]
Here we have substituted the upper limit with a reset event $xreset$, which will reset clock variable $x$ whenever the event is triggered.\footnote{Note that there is an implicit reset value of 0 if no value is given.}
$?xreset$ names a reset event name for $x$, while $*xreset$ triggers the event $xreset$ any time $r_1$ reads the attacked value.
Now, instead of resetting every 1 second, $x$ is reset to 0 any time that $r_1$ reads the attached value, effectively limiting $r_1$ to wait at least 500 ms between each read.

\subsection{Comparison}
We will here make a simple comparison of time constraints expressed in TDLM and with those expressed in \thelang.
The goal here is to ascertain the expressibility and simplicity of \thelang.
In order to fairly compare the labels, we have removed the concept of write policies, even though it is employed by TDLM.

From \cite{pedersen2015} we have a policy attached to smart meter consumption data (stripped of write policies):
\[ \{s_i : u_i, e_j (x[?reset : 1] > 90)[*reset] \} \]
Here we have a smart meter $s_i$ as owner, allowing for user $u_i$ and electrical company $e_j$ as readers.
For $e_j$ there is a time constraint, signifying that $e_j$ must wait 90 days between reads.

In \thelang{} we can express a similar policy:
\begin{center}
\dlmc{\{\{s->u, e @ u: 1s; 90d \}\}}
\end{center}
